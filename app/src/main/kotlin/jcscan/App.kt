/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package jcscan

import apdu4j.core.*
import apdu4j.core.CommandAPDU
import apdu4j.core.ResponseAPDU
import apdu4j.pcsc.*
import apdu4j.pcsc.terminals.*
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.parameters.options.*
import com.github.ajalt.clikt.parameters.types.*
import java.io.*
import java.nio.ByteBuffer
import java.util.*
import javax.smartcardio.*
import jnasmartcardio.Smartcardio
import pro.javacard.gp.*

fun <T> Optional<T>.unwrap(): T? = orElse(null)

class App : CliktCommand() {
    private var manager: TerminalManager? = null
    val tKey by option("-k", "--key", help = "Transport key")
    val defaultGPKey = "404142434445464748494A4B4C4D4E4F"
    val kEnc by option("-ke", "--key-enc", help = "ENC key").default(defaultGPKey)
    val kMac by option("-km", "--key-mac", help = "MAC key").default(defaultGPKey)
    val kDek by option("-kd", "--key-dek", help = "DEK key").default(defaultGPKey)
    val version by option("-v", "--version", help = "Card version").int().default(2)
    val outputFile by option("-o", "--output", help = "Output file")
    override fun run() {
        getTerminalManager()
        val terminals = manager!!.terminals()
        val readers = TerminalManager.listPCSC(terminals.list(), null, false)
        val r = TerminalManager.getLucky(readers, terminals)
        if (r.isEmpty()) {
            echo("No reader found")
            return
        }
        echo("Using " + r)
        var oFile: FileOutputStream? = null
        if (!outputFile.isNullOrEmpty()) {
            echo("Output file: $outputFile")
            oFile = FileOutputStream(File(outputFile))
        }
        val reader = LoggingCardTerminal.getInstance(r.unwrap(), oFile ?: System.out)
        getBIBO(reader).use { it ->
            when (version) {
                2 -> {
                    // JCOP 2.x
                    scanVer2(it)
                }
                3 -> {
                    // JCOP 3
                    scanVer3(it)
                }
                4 -> {
                    // JCOP 4
                    scanVer4(it)
                }
                else -> {
                    echo("Unsupported card version")
                }
            }
        }
    }

    fun getTerminalManager(): TerminalManager? {
        if (manager !== null) return manager
        try {
            TerminalManager.fixPlatformPaths()
            val tf = TerminalManager.getTerminalFactory()
            manager = TerminalManager(tf)
            return manager
        } catch (e: Smartcardio.EstablishContextException) {
            val msg = SCard.getExceptionMessage(e)
            error("No readers: " + msg)
        }
    }

    @Throws(CardException::class)
    fun getBIBO(rdr: CardTerminal): BIBO {
        if (!rdr.isCardPresent()) {
            echo("Waiting for card ...")
            try {
                CardTerminalAppRunner.waitForCard(rdr)
            } catch (e: InterruptedException) {
                echo("Interrupted!")
            }
        }
        val c = rdr.connect("*")
        var bibo = CardBIBO.wrap(c)
        return BlockingBIBO(bibo)
    }

    fun scanVer2(b: BIBO) {
        if (tKey == null) {
            echo("Transport key is required")
            return
        }
        // select root applet
        val tkeyBin = HexUtils.stringToBin(tKey)
        val selectRoot = CommandAPDU(0x00, 0xA4, 0x04, 0x00, tkeyBin)
        val selectRootResp = ResponseAPDU(b.transceive(selectRoot.bytes))
        if (selectRootResp.getSW() != 0x9000) {
            echo("Card returned " + String.format("%04X", selectRootResp.getSW()) + ", exiting!")
            return
        }
        // read from 0xC000F0 to 0xC0FFFF
        for (i in 240..65535 step 256) {
            var readCmd =
                    CommandAPDU(
                            0xC0,
                            0xB0,
                            (i shr 8).toByte().toInt(),
                            (i and 0xFF).toByte().toInt(),
                            256
                    )
            val readResp = ResponseAPDU(b.transceive(readCmd.bytes))
            if (readResp.getSW() != 0x9000) {
                echo("Card returned " + String.format("%04X", readResp.getSW()) + ", exiting!")
                return
            }
            val data = readResp.getData()
            if (data.size > 0) {
                echo(String.format("%06X", i) + " " + HexUtils.bin2hex(data))
            }
        }
    }

    fun scanVer3(b: BIBO) {
        if (tKey == null) {
            echo("Transport key is required")
            return
        }
        // select config applet
        val tkeyBin = HexUtils.stringToBin(tKey)
        val selectConfigApp =
                CommandAPDU(
                        0x00,
                        0xA4,
                        0x04,
                        0x00,
                        HexUtils.stringToBin("A0000003965454000000010101")
                )
        val selectConfigAppResp = ResponseAPDU(b.transceive(selectConfigApp.bytes))
        if (selectConfigAppResp.getSW() != 0x9000) {
            echo(
                    "Card returned " +
                            String.format("%04X", selectConfigAppResp.getSW()) +
                            ", exiting!"
            )
            return
        }
        // auth with transport key
        val authCmd = CommandAPDU(0x00, 0xF0, 0x00, 0x00, tkeyBin)
        val authResp = ResponseAPDU(b.transceive(authCmd.bytes))
        if (authResp.getSW() != 0x9000) {
            echo("Card returned " + String.format("%04X", authResp.getSW()) + ", exiting!")
            return
        }
        readConfigItemV3(b, 0x0018)
        readConfigItemV3(b, 0x0029)
        // EMULATION_SUPPORT
        readConfigItemV3(b, 0x0032)
        readConfigItemV3(b, 0x0033)
        //
        readConfigItemV3(b, 0x104D)
        readConfigItemV3(b, 0x1057)
        // Communication Settings
        // ATR_COLD_IFLEN
        readConfigItemV3(b, 0x108C)
        // ATR_COLD_IFBYTES
        readConfigItemV3(b, 0x108D)
        // ATR_COLD_HISTLEN
        readConfigItemV3(b, 0x108E)
        // ATR_COLD_HISTCHARS
        readConfigItemV3(b, 0x108F)
        // ATR_COLD_CONF
        readConfigItemV3(b, 0x1090)
        readConfigItemV3(b, 0x1091)
        readConfigItemV3(b, 0x1092)
        // ATR_COLD_BAUD
        readConfigItemV3(b, 0x1093)
        // =================================
        // ATR_WARM_IFLEN
        readConfigItemV3(b, 0x1094)
        // ATR_WARM_IFBYTES
        readConfigItemV3(b, 0x1095)
        // ATR_WARM_HISTLEN
        readConfigItemV3(b, 0x1096)
        // ATR_WARM_HISTCHARS
        readConfigItemV3(b, 0x1097)
        // ATR_WARM_CONF
        readConfigItemV3(b, 0x1098)
        readConfigItemV3(b, 0x1099)
        readConfigItemV3(b, 0x109A)
        // ATR_WARM_BAUD
        readConfigItemV3(b, 0x109B)
        readConfigItemV3(b, 0x109C)
        // =================================
        // TCL_ATS_IFBYTES
        readConfigItemV3(b, 0x109E)
        // TCL_ATS_CURRENT_HISTLEN
        readConfigItemV3(b, 0x109F)
        // TCL_ATS_HISTCHARS
        readConfigItemV3(b, 0x10A0)
        // TCL Configs
        readConfigItemV3(b, 0x10A1)
        readConfigItemV3(b, 0x10A2)
        readConfigItemV3(b, 0x10A3)
        readConfigItemV3(b, 0x10A4)
        readConfigItemV3(b, 0x10A5)
        // TCL_L4_ACTIVATION_CONTROL
        readConfigItemV3(b, 0x10A6)
        readConfigItemV3(b, 0x10A7)
        // =================================
        readConfigItemV3(b, 0x200E)
        readConfigItemV3(b, 0x200F)
        readConfigItemV3(b, 0x2010)
        readConfigItemV3(b, 0x2015)
        readConfigItemV3(b, 0x2016)
        readConfigItemV3(b, 0x2018)
        readConfigItemV3(b, 0x4004)
    }

    fun readConfigItemV3(b: BIBO, addr: Short) {
        var readCmd =
                CommandAPDU(
                        0x00,
                        0xB0,
                        0x00,
                        0x00,
                        ByteBuffer.allocate(2).putShort(addr.toShort()).array()
                )
        val readResp = ResponseAPDU(b.transceive(readCmd.bytes))
        val data = readResp.getData()
        if (data.size > 0) {
            echo(String.format("%04X", addr) + " " + HexUtils.bin2hex(data))
        }
    }

    fun scanVer4(b: BIBO) {
        val channel = APDUBIBO(b)
        val gp = GPSession.discover(channel)
        val mode = GPSession.defaultMode.clone()
        val keys =
                PlaintextKeys.fromKeys(
                        HexUtils.hex2bin(kEnc),
                        HexUtils.hex2bin(kMac),
                        HexUtils.hex2bin(kDek)
                )
        try {
            gp.openSecureChannel(keys, null, null, mode)
        } catch (e: GPException) {
            System.err.println("Failed to open secure channel: " + e.message)
            return
        }
        for (i in
                intArrayOf(
                        0x1057,
                        *IntArray(6) { 0x108A + it },
                        *IntArray(16) { 0x1090 + it },
                        *IntArray(16) { 0x10A0 + it },
                        *IntArray(16) { 0x10C0 + it },
                        0x200E,
                        *IntArray(16) { 0x2010 + it },
                        0x4004,
                )) {
            gpGetData(
                    gp,
                    0x00FE,
                    ubyteArrayOf(
                                    0xDFU,
                                    0x2BU,
                                    0x02U,
                                    (i.toInt() shr 8 and 0xFF).toUByte(),
                                    (i.toInt() and 0xFF).toUByte()
                            )
                            .toByteArray()
            )
        }
    }

    fun gpGetData(gp: GPSession, dgi: Int, data: ByteArray?): ResponseAPDU? {
        val cmd =
                CommandAPDU(
                        GPSession.CLA_GP.toInt(),
                        GPSession.INS_GET_DATA.toInt(),
                        // high tag byte
                        (dgi shr 8 and 0xFF).toByte().toInt(),
                        (dgi and 0xFF).toByte().toInt(),
                        data ?: byteArrayOf()
                )
        try {
            val resp = gp.transmit(cmd)
            if (resp.sw == 0x9000) {
                return resp
            }
        } catch (e: GPException) {}
        return null
    }
}

fun main(args: Array<String>) = App().main(args)
